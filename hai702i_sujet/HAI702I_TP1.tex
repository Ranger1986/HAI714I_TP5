\documentclass[a4paper,10pt]{article}
\usepackage{fancyhdr}
\usepackage[pdftex]{graphicx}
%\usepackage{wrapfig}
%\usepackage{xargs}
\usepackage[utf8]{inputenc}
%\usepackage[cyr]{aeguill}
\usepackage[french]{babel}

\usepackage{listings}

\usepackage{color}

\pagestyle{fancy}

\usepackage{url}

\renewcommand\headheight{24pt}

\topmargin -0.5in \textheight 9in \textwidth 7.5in
\oddsidemargin -0.5in \evensidemargin -0.5in %\footskip -0.00in

\lhead{HAI702I}
\rhead{ }
\lfoot{Université de Montpellier}
\rfoot{Master 1 Informatique}

\newcommand\code[1]{\lstinline[columns=fixed]{#1}}

\begin{document}

\lstset{numbers=left, stepnumber=5, frame=single, basicstyle=\scriptsize, tabsize=2, showstringspaces=false}
\begin{center}
\LARGE{Algèbre, géométrie, transformation, calcul numérique}\\
\vspace*{0.4cm}
\normalsize{Travaux pratiques}
\end{center}

Au d\'ebut de ce TP/TD, vous recevrez une archive zip contenant une base de code.
Ce code permet d'afficher un \emph{maillage triangulaire} \`a l'aide d'openGL.
\begin{enumerate}
 \item Vous trouverez la description du code dans le sujet.
 \item Vous devez faire \'evoluer ce code au fur et \`a mesure du TP, pour r\'epondre aux questions.
 \item Vous devez déposez votre code, fichier image de résultat et une phrase sur l'état de votre TP sur le moodle.
\end{enumerate}


\section{Base de code}

T\'el\'echargez l'archive. Pour compiler le code la commande \code{make} et pour l'executer \code{./tp}.

%TODO Faire la description du code
% \subsection{Rendu de maillages}
% 
% Le fichier tp.cpp contient une m\'ethode \code{drawTriangleMesh()}, qui contient du code openGL basique permettant d'afficher un maillage triangulaire.
% 
% \lstset{language=C++}
% \begin{lstlisting}
%     void drawSmoothTriangleMesh( Mesh const & i_mesh ) {
%         // This code is deprecated. 
%         glBegin(GL_TRIANGLES);
%         for(unsigned int tIt = 0 ; tIt < i_mesh.triangles.size(); ++tIt) {
%             Vec3 p0 = i_mesh.vertices[i_mesh.triangles[tIt][0]];
%             Vec3 n0 = i_mesh.normals[i_mesh.triangles[tIt][0]];
% 
%             Vec3 p1 = i_mesh.vertices[i_mesh.triangles[tIt][1]];
%             Vec3 n1 = i_mesh.normals[i_mesh.triangles[tIt][1]];
% 
%             Vec3 p2 = i_mesh.vertices[i_mesh.triangles[tIt][2]];
%             Vec3 n2 = i_mesh.normals[i_mesh.triangles[tIt][2]];
% 
%             glNormal3f( n0[0] , n0[1] , n0[2] );
%             glVertex3f( p0[0] , p0[1] , p0[2] );
%             glNormal3f( n1[0] , n1[1] , n1[2] );
%             glVertex3f( p1[0] , p1[1] , p1[2] );
%             glNormal3f( n2[0] , n2[1] , n2[2] );
%             SglVertex3f( p2[0] , p2[1] , p2[2] );
%     }
%     glEnd();
%     }
% \end{lstlisting}

\section{Calcul géométrique et implémentation de classes}

\label{sec_exo_Vec3}

Compléter la classe Vec3 qui contient les fonctions essentielles pour le calcul de base : assignation, somme, soustraction, multiplication et division par un scalaire, produit scalaire, produit vectoriel, norme,...
\lstset{language=C++}
\begin{lstlisting}
    class Vec3 {
private:
    float mVals[3];
public:
    Vec3() {}
    Vec3( float x , float y , float z ) {
       mVals[0] = x; mVals[1] = y; mVals[2] = z;
    }
    float & operator [] (unsigned int c) { return mVals[c]; }
    float operator [] (unsigned int c) const { return mVals[c]; }
    void operator = (Vec3 const & other) {
       mVals[0] = other[0] ; mVals[1] = other[1]; mVals[2] = other[2];
    }
    float squareLength() const {
       return mVals[0]*mVals[0] + mVals[1]*mVals[1] + mVals[2]*mVals[2];
    }
    float length() const { return sqrt( squareLength() ); }
    void normalize() { float L = length(); mVals[0] /= L; mVals[1] /= L; mVals[2] /= L; }
    static float dot( Vec3 const & a , Vec3 const & b ) {
       //TODO
    }
    static Vec3 cross( Vec3 const & a , Vec3 const & b ) {
        //TODO
    }
    void operator += (Vec3 const & other) {
        mVals[0] += other[0];
        mVals[1] += other[1];
        mVals[2] += other[2];
    }
    void operator -= (Vec3 const & other) {
        mVals[0] -= other[0];
        mVals[1] -= other[1];
        mVals[2] -= other[2];
    }
    void operator *= (float s) {
        mVals[0] *= s;
        mVals[1] *= s;
        mVals[2] *= s;
    }
    void operator /= (float s) {
        mVals[0] /= s;
        mVals[1] /= s;
        mVals[2] /= s;
    }
};
\end{lstlisting}

\begin{enumerate}
 \item Compléter les fonctions de calcul du produit scalaire \code{dot} et du produit vectoriel \code{cross}
\item Compléter la fonctions de \code{Mat3} permettant d'effectuer un produit matriciel
\item Compléter la fonction de \code{Mat3} permettant d'effectuer la multiplication d'appliqquer une matrice de transformation à un point : \code{Mat3*Vec3}.
\end{enumerate}


\paragraph{Remarques}
\begin{enumerate}
 \item On a revu les notions associées au produit scalaire, notamment :
\begin{itemize}
 \item Le produit scalaire entre le vecteur $\mathbf{a}$ et le vecteur $\mathbf{b}$ donne le produit des longueurs multiplié par le cosinus de
l’angle formé par ces vecteurs.
\item Le produit scalaire entre un vecteur $\mathbf{a}$ et un vecteur unitaire $\mathbf{d}$ vaut la longueur (attention au signe !) de $\mathbf{a}$ projeté
sur la (demi-)droite dirigée par $\mathbf{d}$.
\end{itemize}

\item On a revu les notions associées au produit vectoriel, notamment :
\begin{itemize}
 \item Le produit vectoriel entre le vecteur $\mathbf{a}$ et le vecteur $\mathbf{b}$ est orthognal à ces deux vecteurs (et sa direction est donnée
par la ``règle de la main droite''.
\item Sa norme vaut le produit des longueurs multiplié par le sinus de l’angle formé par ces vecteurs.
\end{itemize}
\end{enumerate}

\section{Application}

\begin{enumerate}
\item Pour tester vos calculs, completer les fonctions de calcul de normales aux faces triangulaires \code{computeTrianglesNormals()}. Les normales calculées seront celles du modèle vert. Vous pourrez comparer vos résultats avec les normales du maillage gris \code{transformed_mesh}. 
\item Calculez ensuite les normales par sommet en faisant la moyenne des normales des triangles incidents. N'oubliez pas de normaliser.
\item Remplacer 
\begin{lstlisting}
    for( unsigned int i = 0 ; i < mesh.vertices.size() ; ++i ) {
        transformed_mesh.vertices.push_back( mesh.vertices[i] + mesh_transformation.translation );
    }
\end{lstlisting}
par 
\begin{lstlisting}
    for( unsigned int i = 0 ; i < mesh.vertices.size() ; ++i ) {
        transformed_mesh.vertices.push_back( mesh_transformation.rotation*mesh.vertices[i] 
        + mesh_transformation.translation );
    }
\end{lstlisting}

\item Essayer differentes transformation en mettant à jour  \code{mesh_transformation.rotation} et \code{mesh_transformation.translation}. 
Créer une matrice \code{scale} de mise à l'échelle non-uniforme et essayer \code{mesh_transformation.rotation = mesh_transformation.rotation*scale}. Regarder les normales, que constatez-vous ?

\end{enumerate}
%\section{La STL (Standard Template Library)}


%\begin{itemize}
 %\item Un \code{vector} est un tableau dont l’accès aux éléments est immédiat, et %que l’on peut redimensionner.
%\item Une \code{list} est un ensemble auquel on peut ajouter ou retirer %facilement des éléments en bout de chaîne.
%\item Une \code{map} est une table qui contient des couples clé/valeur.
%\end{itemize}








\end{document}
