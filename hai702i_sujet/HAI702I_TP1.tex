\documentclass[a4paper,10pt]{tp_um}


\input{header.tex}

\newcommand\code[1]{\mintinline{cpp}{#1}}

\title{\Large \sffamily\bfseries TP 1}
\ue{HAI702I}

\begin{document}

\maketitle

\bigskip
\bigskip
\bigskip

Au d\'ebut de ce TP/TD, vous recevrez une archive zip contenant une base de code.
Ce code permet d'afficher un \emph{maillage triangulaire} \`a l'aide d'\texttt{openGL}.
\begin{enumerate}
 \item Vous trouverez la description du code dans le sujet.
 \item Vous devez faire \'evoluer ce code au fur et \`a mesure du TP, pour r\'epondre aux questions.
 \item Vous devez déposez votre code, fichier image de résultat et une phrase sur l'état de votre TP sur le moodle.
\end{enumerate}


\section{Base de code}

T\'el\'echargez l'archive sur le moodle \url{https://moodle.umontpellier.fr/course/view.php?id=22845}. Pour compiler le code et l'exécuter: 
\begin{minted}[bgcolor=blue!4,fontsize=\footnotesize,mathescape,tabsize=4,escapeinside=||, breaklines]{bash}
$ make
$ ./tp
\end{minted}

%TODO Faire la description du code
% \subsection{Rendu de maillages}
% 
% Le fichier tp.cpp contient une m\'ethode \code{drawTriangleMesh()}, qui contient du code openGL basique permettant d'afficher un maillage triangulaire.
% 
% \lstset{language=C++}
% \begin{lstlisting}
%     void drawSmoothTriangleMesh( Mesh const & i_mesh ) {
%         // This code is deprecated. 
%         glBegin(GL_TRIANGLES);
%         for(unsigned int tIt = 0 ; tIt < i_mesh.triangles.size(); ++tIt) {
%             Vec3 p0 = i_mesh.vertices[i_mesh.triangles[tIt][0]];
%             Vec3 n0 = i_mesh.normals[i_mesh.triangles[tIt][0]];
% 
%             Vec3 p1 = i_mesh.vertices[i_mesh.triangles[tIt][1]];
%             Vec3 n1 = i_mesh.normals[i_mesh.triangles[tIt][1]];
% 
%             Vec3 p2 = i_mesh.vertices[i_mesh.triangles[tIt][2]];
%             Vec3 n2 = i_mesh.normals[i_mesh.triangles[tIt][2]];
% 
%             glNormal3f( n0[0] , n0[1] , n0[2] );
%             glVertex3f( p0[0] , p0[1] , p0[2] );
%             glNormal3f( n1[0] , n1[1] , n1[2] );
%             glVertex3f( p1[0] , p1[1] , p1[2] );
%             glNormal3f( n2[0] , n2[1] , n2[2] );
%             SglVertex3f( p2[0] , p2[1] , p2[2] );
%     }
%     glEnd();
%     }
% \end{lstlisting}

\section{Calcul géométrique et implémentation de classes}

\label{sec_exo_Vec3}

Compléter la classe \code{Vec3} qui contient les fonctions essentielles pour le calcul de base : assignation, somme, soustraction, multiplication et division par un scalaire, produit scalaire, produit vectoriel, norme,\ldots

\begin{minted}[bgcolor=blue!4,fontsize=\footnotesize,mathescape,tabsize=4,escapeinside=||, linenos, breaklines]{cpp}
    class Vec3 {
private:
    float mVals[3];
public:
    Vec3() {}
    Vec3( float x , float y , float z ) {
       mVals[0] = x; mVals[1] = y; mVals[2] = z;
    }
    float & operator [] (unsigned int c) { return mVals[c]; }
    float operator [] (unsigned int c) const { return mVals[c]; }
    void operator = (Vec3 const & other) {
       mVals[0] = other[0] ; mVals[1] = other[1]; mVals[2] = other[2];
    }
    float squareLength() const {
       return mVals[0]*mVals[0] + mVals[1]*mVals[1] + mVals[2]*mVals[2];
    }
    float length() const { return sqrt( squareLength() ); }
    void normalize() { float L = length(); mVals[0] /= L; mVals[1] /= L; mVals[2] /= L; }
    static float dot( Vec3 const & a , Vec3 const & b ) {
       //TODO
    }
    static Vec3 cross( Vec3 const & a , Vec3 const & b ) {
        //TODO
    }
    void operator += (Vec3 const & other) {
        mVals[0] += other[0];
        mVals[1] += other[1];
        mVals[2] += other[2];
    }
    void operator -= (Vec3 const & other) {
        mVals[0] -= other[0];
        mVals[1] -= other[1];
        mVals[2] -= other[2];
    }
    void operator *= (float s) {
        mVals[0] *= s;
        mVals[1] *= s;
        mVals[2] *= s;
    }
    void operator /= (float s) {
        mVals[0] /= s;
        mVals[1] /= s;
        mVals[2] /= s;
    }
};
\end{minted}

\begin{enumerate}
 \item Compléter les fonctions de calcul du produit scalaire \code{dot} et du produit vectoriel \code{cross}
\item Compléter la fonctions de \code{Mat3} permettant d'effectuer un produit matriciel
\item Compléter la fonction de \code{Mat3} permettant d'effectuer la multiplication d'appliquer une matrice de transformation à un point : \code{Mat3*Vec3}.
\end{enumerate}


\begin{remark}
    \begin{enumerate}
        \item On a revu les notions associées au produit scalaire, notamment :
            \begin{itemize}
                \item Le produit scalaire entre le vecteur $\mathbf{a}$ et le vecteur $\mathbf{b}$ donne le produit des longueurs multiplié par le cosinus de
                    l’angle formé par ces vecteurs.
                \item Le produit scalaire entre un vecteur $\mathbf{a}$ et un vecteur unitaire $\mathbf{d}$ vaut la longueur (attention au signe !) de $\mathbf{a}$ projeté
                    sur la (demi-)droite dirigée par $\mathbf{d}$.
            \end{itemize}

        \item On a revu les notions associées au produit vectoriel, notamment :
            \begin{itemize}
                \item Le produit vectoriel entre le vecteur $\mathbf{a}$ et le vecteur $\mathbf{b}$ est orthognal à ces deux vecteurs (et sa direction est donnée
                        par la ``règle de la main droite''.
                    \item Sa norme vaut le produit des longueurs multiplié par le sinus de l’angle formé par ces vecteurs.
                \end{itemize}
        \end{enumerate}
    \end{remark}

\section{Application}

\begin{enumerate}
\item Pour tester vos calculs, compléter les fonctions de calcul de normales aux faces triangulaires \code{computeTrianglesNormals()}. Les normales calculées seront celles du modèle vert. Vous pourrez comparer vos résultats avec les normales du maillage gris \code{transformed_mesh}. 
\item Calculez ensuite les normales par sommet en faisant la moyenne des normales des triangles incidents. N'oubliez pas de normaliser.
\item Remplacer 
\begin{minted}[bgcolor=blue!4,fontsize=\footnotesize,mathescape,tabsize=4,escapeinside=||, linenos, breaklines]{cpp}
    for( unsigned int i = 0 ; i < mesh.vertices.size() ; ++i ) {
        transformed_mesh.vertices.push_back( mesh.vertices[i] + mesh_transformation.translation );
    }
\end{minted}
par 
\begin{minted}[bgcolor=blue!4,fontsize=\footnotesize,mathescape,tabsize=4,escapeinside=||, linenos, breaklines]{cpp}
    for( unsigned int i = 0 ; i < mesh.vertices.size() ; ++i ) {
        transformed_mesh.vertices.push_back( mesh_transformation.rotation*mesh.vertices[i] 
        + mesh_transformation.translation );
    }
\end{minted}

\item Essayer differentes transformation en mettant à jour  \code{mesh_transformation.rotation} et \code{mesh_transformation.translation}. 
Créer une matrice \code{scale} de mise à l'échelle non-uniforme et essayer \code{mesh_transformation.rotation = mesh_transformation.rotation*scale}. Regarder les normales, que constatez vous?

\end{enumerate}

%\section{La STL (Standard Template Library)}


%\begin{itemize}
 %\item Un \code{vector} est un tableau dont l’accès aux éléments est immédiat, et %que l’on peut redimensionner.
%\item Une \code{list} est un ensemble auquel on peut ajouter ou retirer %facilement des éléments en bout de chaîne.
%\item Une \code{map} est une table qui contient des couples clé/valeur.
%\end{itemize}








\end{document}
